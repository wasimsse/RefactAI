package ai.refact.engine.model;

import lombok.Builder;
import lombok.Data;
import java.util.List;
import java.util.Map;

/**
 * Model representing a security vulnerability found in the code.
 * 
 * Technology Stack:
 * - Lombok for boilerplate code reduction
 * - Builder pattern for flexible object creation
 * - CVSS-based risk scoring
 */
@Data
@Builder
public class SecurityVulnerability {
    
    private String id;
    private String title;
    private String description;
    private VulnerabilitySeverity severity;
    private VulnerabilityCategory category;
    private String cweId;
    private String owaspCategory;
    
    // Location information
    private String filePath;
    private Integer startLine;
    private Integer endLine;
    private String codeSnippet;
    
    // Risk scoring
    private Double cvssScore;
    private String cvssVector;
    private Double exploitabilityScore;
    private Double impactScore;
    
    // Remediation
    private String recommendation;
    private List<String> remediationSteps;
    private Integer estimatedEffortHours;
    private String fixPriority; // IMMEDIATE, HIGH, MEDIUM, LOW
    
    // References
    private List<String> references;
    private Map<String, String> metadata;
    
    // Review status
    private String reviewStatus; // PENDING, REVIEWED, FALSE_POSITIVE, ACCEPTED_RISK, FIXED
    private String reviewComment;
    private String reviewedBy;
    
    /**
     * Calculate overall risk score based on CVSS, exploitability, and impact.
     */
    public double calculateRiskScore() {
        double baseScore = cvssScore != null ? cvssScore : severity.getMaxScore();
        double exploitability = exploitabilityScore != null ? exploitabilityScore : 5.0;
        double impact = impactScore != null ? impactScore : 5.0;
        
        // Weighted calculation: 50% CVSS, 30% exploitability, 20% impact
        return (baseScore * 0.5) + (exploitability * 0.3) + (impact * 0.2);
    }
    
    /**
     * Check if vulnerability requires immediate attention.
     */
    public boolean isHighPriority() {
        return severity == VulnerabilitySeverity.CRITICAL || 
               severity == VulnerabilitySeverity.HIGH;
    }
    
    /**
     * Check if vulnerability is in OWASP Top 10.
     */
    public boolean isOwaspTop10() {
        return category != null && category.isOwaspTop10();
    }
    
    /**
     * Get human-readable severity description.
     */
    public String getSeverityDescription() {
        return severity != null ? severity.getDescription() : "Unknown severity";
    }
    
    /**
     * Get formatted location string.
     */
    public String getLocationString() {
        if (filePath == null) return "Unknown location";
        
        StringBuilder location = new StringBuilder(filePath);
        if (startLine != null) {
            location.append(":").append(startLine);
            if (endLine != null && !endLine.equals(startLine)) {
                location.append("-").append(endLine);
            }
        }
        return location.toString();
    }
    
    /**
     * Check if vulnerability has been reviewed.
     */
    public boolean isReviewed() {
        return reviewStatus != null && !reviewStatus.equals("PENDING");
    }
    
    /**
     * Check if vulnerability is a false positive.
     */
    public boolean isFalsePositive() {
        return "FALSE_POSITIVE".equals(reviewStatus);
    }
    
    /**
     * Check if risk has been accepted.
     */
    public boolean isRiskAccepted() {
        return "ACCEPTED_RISK".equals(reviewStatus);
    }
    
    /**
     * Check if vulnerability has been fixed.
     */
    public boolean isFixed() {
        return "FIXED".equals(reviewStatus);
    }
    
    /**
     * Get display color based on severity.
     */
    public String getDisplayColor() {
        return severity != null ? severity.getColorCode() : "#6B7280";
    }
}
