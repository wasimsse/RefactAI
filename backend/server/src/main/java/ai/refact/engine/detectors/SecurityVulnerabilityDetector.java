package ai.refact.engine.detectors;

import ai.refact.engine.model.SecurityVulnerability;
import ai.refact.engine.model.VulnerabilityType;
import ai.refact.engine.model.VulnerabilitySeverity;
import ai.refact.engine.model.VulnerabilityCategory;
import org.springframework.stereotype.Component;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;
import java.util.regex.Pattern;

@Component
public class SecurityVulnerabilityDetector {
    
    private static final Logger logger = LoggerFactory.getLogger(SecurityVulnerabilityDetector.class);
    
    // SQL Injection patterns
    private static final List<Pattern> SQL_INJECTION_PATTERNS = Arrays.asList(
        Pattern.compile("(?i).*executeQuery\\s*\\(.*\\+.*\\).*"),
        Pattern.compile("(?i).*executeUpdate\\s*\\(.*\\+.*\\).*"),
        Pattern.compile("(?i).*Statement.*\\+.*\\).*"),
        Pattern.compile("(?i).*PreparedStatement.*setString.*\\+.*\\).*")
    );
    
    // XSS patterns
    private static final List<Pattern> XSS_PATTERNS = Arrays.asList(
        Pattern.compile("(?i).*innerHTML\\s*=\\s*.*\\+.*\\).*"),
        Pattern.compile("(?i).*outerHTML\\s*=\\s*.*\\+.*\\).*"),
        Pattern.compile("(?i).*document\\.write\\s*\\(.*\\+.*\\).*"),
        Pattern.compile("(?i).*eval\\s*\\(.*\\+.*\\).*")
    );
    
    // Hardcoded secrets patterns
    private static final List<Pattern> HARDCODED_SECRETS_PATTERNS = Arrays.asList(
        Pattern.compile("(?i).*password\\s*=\\s*[\"'][^\"']{8,}[\"'].*"),
        Pattern.compile("(?i).*secret\\s*=\\s*[\"'][^\"']{8,}[\"'].*"),
        Pattern.compile("(?i).*api_key\\s*=\\s*[\"'][^\"']{8,}[\"'].*"),
        Pattern.compile("(?i).*token\\s*=\\s*[\"'][^\"']{8,}[\"'].*"),
        Pattern.compile("(?i).*private_key\\s*=\\s*[\"'][^\"']{8,}[\"'].*")
    );
    
    // Weak cryptography patterns
    private static final List<Pattern> WEAK_CRYPTO_PATTERNS = Arrays.asList(
        Pattern.compile("(?i).*MD5.*"),
        Pattern.compile("(?i).*SHA1.*"),
        Pattern.compile("(?i).*DES.*"),
        Pattern.compile("(?i).*ECB.*"),
        Pattern.compile("(?i).*new\\s+Random\\s*\\(\\).*")
    );
    
    // Path traversal patterns
    private static final List<Pattern> PATH_TRAVERSAL_PATTERNS = Arrays.asList(
        Pattern.compile("(?i).*FileInputStream\\s*\\(.*\\+.*\\.\\..*\\).*"),
        Pattern.compile("(?i).*FileOutputStream\\s*\\(.*\\+.*\\.\\..*\\).*"),
        Pattern.compile("(?i).*new\\s+File\\s*\\(.*\\+.*\\.\\..*\\).*")
    );
    
    // Command injection patterns
    private static final List<Pattern> COMMAND_INJECTION_PATTERNS = Arrays.asList(
        Pattern.compile("(?i).*Runtime\\.getRuntime\\(\\)\\.exec\\s*\\(.*\\+.*\\).*"),
        Pattern.compile("(?i).*ProcessBuilder\\s*\\(.*\\+.*\\).*")
    );
    
    // Deserialization patterns
    private static final List<Pattern> DESERIALIZATION_PATTERNS = Arrays.asList(
        Pattern.compile("(?i).*ObjectInputStream.*readObject.*"),
        Pattern.compile("(?i).*XMLDecoder.*readObject.*"),
        Pattern.compile("(?i).*Yaml.*load.*")
    );
    
    // CSRF patterns
    private static final List<Pattern> CSRF_PATTERNS = Arrays.asList(
        Pattern.compile("(?i).*@RequestMapping.*POST.*"),
        Pattern.compile("(?i).*@PostMapping.*"),
        Pattern.compile("(?i).*@PutMapping.*"),
        Pattern.compile("(?i).*@DeleteMapping.*")
    );
    
    // Insecure CORS patterns
    private static final List<Pattern> INSECURE_CORS_PATTERNS = Arrays.asList(
        Pattern.compile("(?i).*setAllowedOrigins\\s*\\(\\s*\"\\*\"\\s*\\).*"),
        Pattern.compile("(?i).*Access-Control-Allow-Origin.*\\*.*")
    );
    
    // Logging sensitive data patterns
    private static final List<Pattern> SENSITIVE_LOGGING_PATTERNS = Arrays.asList(
        Pattern.compile("(?i).*logger\\.(info|debug|warn|error)\\s*\\(.*password.*\\).*"),
        Pattern.compile("(?i).*logger\\.(info|debug|warn|error)\\s*\\(.*token.*\\).*"),
        Pattern.compile("(?i).*logger\\.(info|debug|warn|error)\\s*\\(.*secret.*\\).*"),
        Pattern.compile("(?i).*System\\.out\\.println\\s*\\(.*password.*\\).*")
    );
    
    // Memory vulnerabilities patterns
    private static final List<Pattern> MEMORY_VULNERABILITY_PATTERNS = Arrays.asList(
        Pattern.compile("(?i).*new\\s+\\[\\]\\s*\\{.*\\}.*"),
        Pattern.compile("(?i).*ArrayList.*add.*"),
        Pattern.compile("(?i).*HashMap.*put.*")
    );
    
    // Network security patterns
    private static final List<Pattern> NETWORK_SECURITY_PATTERNS = Arrays.asList(
        Pattern.compile("(?i).*HttpURLConnection.*"),
        Pattern.compile("(?i).*URL.*openConnection.*"),
        Pattern.compile("(?i).*Socket.*")
    );
    
    public List<SecurityVulnerability> detectSecurityVulnerabilities(Path filePath) throws IOException {
        List<SecurityVulnerability> vulnerabilities = new ArrayList<>();
        
        if (!Files.exists(filePath) || !Files.isRegularFile(filePath)) {
            return vulnerabilities;
        }
        
        String fileName = filePath.getFileName().toString().toLowerCase();
        if (!fileName.endsWith(".java") && !fileName.endsWith(".js") && !fileName.endsWith(".ts") && 
            !fileName.endsWith(".py") && !fileName.endsWith(".php") && !fileName.endsWith(".rb")) {
            return vulnerabilities;
        }
        
        List<String> lines = Files.readAllLines(filePath);
        String content = String.join("\n", lines);
        
        // Detect SQL Injection
        vulnerabilities.addAll(detectSQLInjection(lines, content, filePath));
        
        // Detect XSS
        vulnerabilities.addAll(detectXSS(lines, content, filePath));
        
        // Detect Hardcoded Secrets
        vulnerabilities.addAll(detectHardcodedSecrets(lines, content, filePath));
        
        // Detect Weak Cryptography
        vulnerabilities.addAll(detectWeakCryptography(lines, content, filePath));
        
        // Detect Path Traversal
        vulnerabilities.addAll(detectPathTraversal(lines, content, filePath));
        
        // Detect Command Injection
        vulnerabilities.addAll(detectCommandInjection(lines, content, filePath));
        
        // Detect Deserialization
        vulnerabilities.addAll(detectDeserialization(lines, content, filePath));
        
        // Detect CSRF
        vulnerabilities.addAll(detectCSRF(lines, content, filePath));
        
        // Detect Insecure CORS
        vulnerabilities.addAll(detectInsecureCORS(lines, content, filePath));
        
        // Detect Sensitive Logging
        vulnerabilities.addAll(detectSensitiveLogging(lines, content, filePath));
        
        // Detect Memory Vulnerabilities
        vulnerabilities.addAll(detectMemoryVulnerabilities(lines, content, filePath));
        
        // Detect Network Security Issues
        vulnerabilities.addAll(detectNetworkSecurityIssues(lines, content, filePath));
        
        return vulnerabilities;
    }
    
    private List<SecurityVulnerability> detectSQLInjection(List<String> lines, String content, Path filePath) {
        List<SecurityVulnerability> vulnerabilities = new ArrayList<>();
        
        for (int i = 0; i < lines.size(); i++) {
            String line = lines.get(i);
            for (Pattern pattern : SQL_INJECTION_PATTERNS) {
                if (pattern.matcher(line).matches()) {
                    vulnerabilities.add(new SecurityVulnerability(
                        VulnerabilityType.SQL_INJECTION,
                        VulnerabilityCategory.INPUT_INJECTION,
                        VulnerabilitySeverity.CRITICAL,
                        "SQL Injection Vulnerability",
                        "Potential SQL injection detected. Use prepared statements or parameterized queries.",
                        "Use PreparedStatement with parameterized queries instead of string concatenation.",
                        i + 1,
                        i + 1,
                        Arrays.asList("Use PreparedStatement", "Validate and sanitize input", "Use ORM frameworks")
                    ));
                }
            }
        }
        
        return vulnerabilities;
    }
    
    private List<SecurityVulnerability> detectXSS(List<String> lines, String content, Path filePath) {
        List<SecurityVulnerability> vulnerabilities = new ArrayList<>();
        
        for (int i = 0; i < lines.size(); i++) {
            String line = lines.get(i);
            for (Pattern pattern : XSS_PATTERNS) {
                if (pattern.matcher(line).matches()) {
                    vulnerabilities.add(new SecurityVulnerability(
                        VulnerabilityType.XSS,
                        VulnerabilityCategory.WEB_API_SECURITY,
                        VulnerabilitySeverity.HIGH,
                        "Cross-Site Scripting (XSS) Vulnerability",
                        "Potential XSS vulnerability detected. User input is being rendered without proper sanitization.",
                        "Sanitize user input before rendering. Use Content Security Policy (CSP).",
                        i + 1,
                        i + 1,
                        Arrays.asList("Sanitize input", "Use CSP headers", "Validate output encoding")
                    ));
                }
            }
        }
        
        return vulnerabilities;
    }
    
    private List<SecurityVulnerability> detectHardcodedSecrets(List<String> lines, String content, Path filePath) {
        List<SecurityVulnerability> vulnerabilities = new ArrayList<>();
        
        for (int i = 0; i < lines.size(); i++) {
            String line = lines.get(i);
            for (Pattern pattern : HARDCODED_SECRETS_PATTERNS) {
                if (pattern.matcher(line).matches()) {
                    vulnerabilities.add(new SecurityVulnerability(
                        VulnerabilityType.HARDCODED_SECRETS,
                        VulnerabilityCategory.CRYPTOGRAPHY_SECRETS,
                        VulnerabilitySeverity.HIGH,
                        "Hardcoded Secret Detected",
                        "Hardcoded password, secret, or API key found in source code.",
                        "Use environment variables, configuration files, or secret management services.",
                        i + 1,
                        i + 1,
                        Arrays.asList("Use environment variables", "Implement secret management", "Rotate secrets regularly")
                    ));
                }
            }
        }
        
        return vulnerabilities;
    }
    
    private List<SecurityVulnerability> detectWeakCryptography(List<String> lines, String content, Path filePath) {
        List<SecurityVulnerability> vulnerabilities = new ArrayList<>();
        
        for (int i = 0; i < lines.size(); i++) {
            String line = lines.get(i);
            for (Pattern pattern : WEAK_CRYPTO_PATTERNS) {
                if (pattern.matcher(line).matches()) {
                    vulnerabilities.add(new SecurityVulnerability(
                        VulnerabilityType.WEAK_CRYPTOGRAPHY,
                        VulnerabilityCategory.CRYPTOGRAPHY_SECRETS,
                        VulnerabilitySeverity.HIGH,
                        "Weak Cryptography Detected",
                        "Use of deprecated or weak cryptographic algorithms detected.",
                        "Use modern cryptographic algorithms (AES-256, SHA-256, etc.) and secure random number generators.",
                        i + 1,
                        i + 1,
                        Arrays.asList("Use AES-256", "Use SHA-256", "Use SecureRandom", "Avoid MD5/SHA1")
                    ));
                }
            }
        }
        
        return vulnerabilities;
    }
    
    private List<SecurityVulnerability> detectPathTraversal(List<String> lines, String content, Path filePath) {
        List<SecurityVulnerability> vulnerabilities = new ArrayList<>();
        
        for (int i = 0; i < lines.size(); i++) {
            String line = lines.get(i);
            for (Pattern pattern : PATH_TRAVERSAL_PATTERNS) {
                if (pattern.matcher(line).matches()) {
                    vulnerabilities.add(new SecurityVulnerability(
                        VulnerabilityType.PATH_TRAVERSAL,
                        VulnerabilityCategory.FILE_RESOURCE_HANDLING,
                        VulnerabilitySeverity.HIGH,
                        "Path Traversal Vulnerability",
                        "Potential path traversal vulnerability allowing access to files outside intended directory.",
                        "Validate and sanitize file paths. Use Path.normalize() and restrict access to safe directories.",
                        i + 1,
                        i + 1,
                        Arrays.asList("Validate file paths", "Use Path.normalize()", "Restrict directory access")
                    ));
                }
            }
        }
        
        return vulnerabilities;
    }
    
    private List<SecurityVulnerability> detectCommandInjection(List<String> lines, String content, Path filePath) {
        List<SecurityVulnerability> vulnerabilities = new ArrayList<>();
        
        for (int i = 0; i < lines.size(); i++) {
            String line = lines.get(i);
            for (Pattern pattern : COMMAND_INJECTION_PATTERNS) {
                if (pattern.matcher(line).matches()) {
                    vulnerabilities.add(new SecurityVulnerability(
                        VulnerabilityType.COMMAND_INJECTION,
                        VulnerabilityCategory.INPUT_INJECTION,
                        VulnerabilitySeverity.CRITICAL,
                        "Command Injection Vulnerability",
                        "Potential command injection vulnerability allowing execution of arbitrary commands.",
                        "Avoid executing system commands. If necessary, validate and sanitize all input parameters.",
                        i + 1,
                        i + 1,
                        Arrays.asList("Avoid system commands", "Validate input", "Use built-in APIs")
                    ));
                }
            }
        }
        
        return vulnerabilities;
    }
    
    private List<SecurityVulnerability> detectDeserialization(List<String> lines, String content, Path filePath) {
        List<SecurityVulnerability> vulnerabilities = new ArrayList<>();
        
        for (int i = 0; i < lines.size(); i++) {
            String line = lines.get(i);
            for (Pattern pattern : DESERIALIZATION_PATTERNS) {
                if (pattern.matcher(line).matches()) {
                    vulnerabilities.add(new SecurityVulnerability(
                        VulnerabilityType.DESERIALIZATION,
                        VulnerabilityCategory.INPUT_INJECTION,
                        VulnerabilitySeverity.HIGH,
                        "Insecure Deserialization",
                        "Potential insecure deserialization vulnerability.",
                        "Use safe deserialization methods, implement input validation, and consider using JSON instead.",
                        i + 1,
                        i + 1,
                        Arrays.asList("Validate input", "Use JSON", "Implement allowlist")
                    ));
                }
            }
        }
        
        return vulnerabilities;
    }
    
    private List<SecurityVulnerability> detectCSRF(List<String> lines, String content, Path filePath) {
        List<SecurityVulnerability> vulnerabilities = new ArrayList<>();
        
        for (int i = 0; i < lines.size(); i++) {
            String line = lines.get(i);
            for (Pattern pattern : CSRF_PATTERNS) {
                if (pattern.matcher(line).matches()) {
                    vulnerabilities.add(new SecurityVulnerability(
                        VulnerabilityType.CSRF,
                        VulnerabilityCategory.WEB_API_SECURITY,
                        VulnerabilitySeverity.MEDIUM,
                        "Missing CSRF Protection",
                        "HTTP method that modifies state without CSRF protection detected.",
                        "Implement CSRF tokens, use SameSite cookies, and validate request origin.",
                        i + 1,
                        i + 1,
                        Arrays.asList("Add CSRF tokens", "Validate origin", "Use SameSite cookies")
                    ));
                }
            }
        }
        
        return vulnerabilities;
    }
    
    private List<SecurityVulnerability> detectInsecureCORS(List<String> lines, String content, Path filePath) {
        List<SecurityVulnerability> vulnerabilities = new ArrayList<>();
        
        for (int i = 0; i < lines.size(); i++) {
            String line = lines.get(i);
            for (Pattern pattern : INSECURE_CORS_PATTERNS) {
                if (pattern.matcher(line).matches()) {
                    vulnerabilities.add(new SecurityVulnerability(
                        VulnerabilityType.INSECURE_CORS,
                        VulnerabilityCategory.WEB_API_SECURITY,
                        VulnerabilitySeverity.MEDIUM,
                        "Insecure CORS Configuration",
                        "CORS is configured to allow all origins (*), which is insecure.",
                        "Configure CORS to allow only specific trusted origins.",
                        i + 1,
                        i + 1,
                        Arrays.asList("Restrict origins", "Use specific domains", "Implement proper CORS")
                    ));
                }
            }
        }
        
        return vulnerabilities;
    }
    
    private List<SecurityVulnerability> detectSensitiveLogging(List<String> lines, String content, Path filePath) {
        List<SecurityVulnerability> vulnerabilities = new ArrayList<>();
        
        for (int i = 0; i < lines.size(); i++) {
            String line = lines.get(i);
            for (Pattern pattern : SENSITIVE_LOGGING_PATTERNS) {
                if (pattern.matcher(line).matches()) {
                    vulnerabilities.add(new SecurityVulnerability(
                        VulnerabilityType.SENSITIVE_DATA_EXPOSURE,
                        VulnerabilityCategory.LOGGING_MONITORING,
                        VulnerabilitySeverity.MEDIUM,
                        "Sensitive Data in Logs",
                        "Sensitive information (passwords, tokens) is being logged.",
                        "Avoid logging sensitive data. Use placeholder values or redact sensitive information.",
                        i + 1,
                        i + 1,
                        Arrays.asList("Redact sensitive data", "Use placeholders", "Implement log filtering")
                    ));
                }
            }
        }
        
        return vulnerabilities;
    }
    
    private List<SecurityVulnerability> detectMemoryVulnerabilities(List<String> lines, String content, Path filePath) {
        List<SecurityVulnerability> vulnerabilities = new ArrayList<>();
        
        for (int i = 0; i < lines.size(); i++) {
            String line = lines.get(i);
            for (Pattern pattern : MEMORY_VULNERABILITY_PATTERNS) {
                if (pattern.matcher(line).matches()) {
                    vulnerabilities.add(new SecurityVulnerability(
                        VulnerabilityType.MEMORY_VULNERABILITY,
                        VulnerabilityCategory.MEMORY_RUNTIME,
                        VulnerabilitySeverity.LOW,
                        "Potential Memory Issue",
                        "Potential memory-related vulnerability or inefficient memory usage.",
                        "Review memory usage patterns and implement proper resource management.",
                        i + 1,
                        i + 1,
                        Arrays.asList("Review memory usage", "Implement proper cleanup", "Use try-with-resources")
                    ));
                }
            }
        }
        
        return vulnerabilities;
    }
    
    private List<SecurityVulnerability> detectNetworkSecurityIssues(List<String> lines, String content, Path filePath) {
        List<SecurityVulnerability> vulnerabilities = new ArrayList<>();
        
        for (int i = 0; i < lines.size(); i++) {
            String line = lines.get(i);
            for (Pattern pattern : NETWORK_SECURITY_PATTERNS) {
                if (pattern.matcher(line).matches()) {
                    vulnerabilities.add(new SecurityVulnerability(
                        VulnerabilityType.NETWORK_SECURITY,
                        VulnerabilityCategory.NETWORK_TRANSPORT_SECURITY,
                        VulnerabilitySeverity.MEDIUM,
                        "Network Security Consideration",
                        "Network communication detected. Ensure proper security measures are implemented.",
                        "Use HTTPS/TLS, implement proper authentication, and validate all network input/output.",
                        i + 1,
                        i + 1,
                        Arrays.asList("Use HTTPS/TLS", "Implement authentication", "Validate network I/O")
                    ));
                }
            }
        }
        
        return vulnerabilities;
    }
}
